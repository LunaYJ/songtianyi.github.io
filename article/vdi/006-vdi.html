<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<header style="padding-bottom:50px">
<ul>
	<li style="float:left;padding-right:20px"><a href="../../index.html">Home</a></li>
</ul>
</header>

<style type="text/css">
	div{
		font-size:12pt;
	}
	p{
		text-indent:2em;/*段落缩进*/
		line-height:140%;/*行间距*/
	}
	blockquote {
		background:#f9f9f9;
		border-left:10px solid darkblue;
	}
	blockquote p {
		display:inline;
	}
</style>

<!--code examples

<a href=""></a>

<li><a style="text-decoration:none" href="#"></a></li>

<h2 id=""></h2>

<div style="text-align:center">
	<img  src="">
	<p>图 </p>
</div>
	
<sup>sup>

<div style="background:#eee;border:1px solid #ccc;padding:5px 10px;">
</div>

-->


<div>

	<!--博文标题和作者信息-->
	<h2 style="text-align:center">《Foundations of GTK+ Development》笔记</h2>
	<h5 style="text-align:right">update@2013-08-29</h5>



	<!--第一段，介绍文章的内容-->
	<p>
	一些笔记，方便忘记的时候查阅。
	</p>




	<ul>
		<li>Idle functions allow you to call a function when the processor is not doing anything else for the application</li>
		<li>Timeouts are used to call a function at a specified interval of time provided by you</li>
		<li>One advantage of GdkPixbuf images is that images can be reference-counted. This means that a GdkPixbuf image can be displayed in multiple locations, while only being stored in memory once. It will only be destroyed when all reference counts are decremented</li>
		<li>autoconf is used for configuration and dealing with portability issues, automake for building makefiles, libtool for building shared libraries, and make for compiling and installing binaries.</li>
		<li>The gtk_init() function will terminate your application if it is unable to initialize the GUI or has any other significant problems that cannot be resolved. If you would like your applica- tion to fall back on a text interface when GUI initialization fails, you need to use gtk_init_check().</li>
		<li>Widget hierarchy in GTK+ is a singly inherited system, which means that each child can have only one direct parent. </li>
		<li>The widget may not be immediately shown when you call gtk_widget_show(), because GTK+ queues the widget until all preprocessing is complete before it is drawn onto the screen.It is important to note that gtk_widget_show() will only show the widget it is called on. If the widget has children that are not already set as visible, they will not be drawn on the screen.  Furthermore, if the widget’s parent is not visible, it will not be drawn on the screen. Instead, it will be queued until its parent is set as visible as well.</li>
		<li>We then call gtk_widget_show_all() on the window. This function recursively draws the window, its children, its children’s children and so on. Without this function, you would have to call gtk_widget_show() on every single child widget</li>
		<li>When typing the signal name, the underscore and dash characters are interchangeable.  They will be parsed as the same character, so it does not make any difference which one you choose.</li>
		<li>If TRUE is returned from an event callback, GTK+ assumes the event has already been handled and will not con- tinue. By returning FALSE, you are telling GTK+ to continue handling the event. </li>
		<li>There is no way to set a widget with a width or height of less than 1 pixel, but by passing 0 to either parameter, GTK+ will make the widget as small as possible. </li>
		<li>Unlike gtk_widget_set_size_request(), gtk_window_set_default_size() only sets the initial size of the window—it does not prevent the user from resizing it to a larger or smaller size. </li>
		<li>While it is acceptable to use either a dash or an underscore when typing signal names, you must always use dashes when using the notify signal. For example, if you need to monitor GtkWidget’s can-focus property, notify::can_focus is not acceptable! Remember that notify is the signal name, and can-focus is the name of the widget property.</li>
		<li>You must call gtk_widget_set_events() before you call gtk_widget_realize() on the widget. If a widget has already been realized by GTK+, you will have to instead use gtk_widget_add_events() to add event masks.</li>
		<li>Neither the key nor the value is actually stored by GHashTable in GLib, so the pair must exist for the lifetime of the hash table itself.  That means you should not use temporary strings such as those returned from GTK+ wid- gets. If you need to use a temporary string, you should call g_strdup() to make a permanent copy of the string.</li>
		<li>When dealing with key codes, you need to be careful because you many need to supply multiple keys for the same action in some cases. For example, if you want to catch the number 1 key, you will need to watch for GDK_1 and GDK_KP_1—they correspond to the 1 key at the top of the keyboard and the 1 key on the numeric keypad.</li>
		<li>To deselect the currently selected day, you should use gtk_calendar_select_day() with a date value of zero.</li>
		<li>GTK_RECENT_SORT_CUSTOM: Use a custom sorting function to sort the recent files. To use this, you will need to use gtk_recent_manager_set_sort_func() to define the sorting function to use.</li>
		<li>With the GtkRecentChooserDialog widgets, it is possible to choose multiple files with gtk_recent_chooser_set_select_multiple(). If the user can select multiple files, you will want to use gtk_recent_chooser_get_uris() to retrieve all of the selected files.</li>
	</ul>
	
</div>

